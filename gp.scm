(define (make-population)
  '())

(define (population-increase population specimen)
  (let* ((score (error specimen))
         (entity (cons (simplify specimen) score))
         (goes-in-front (lambda (x) (< score (cdr x)))))
    (let loop ((tail population))
      (if (or (null? tail) (goes-in-front (car tail)))
          (cons entity tail)
          (cons (car tail) (loop (cdr tail)))))))

(define (triangular n)                                                           
   (/ (* n (+ n 1)) 2))                                                          
                                                                                 
(define (wchoose lst)                                                            
  (let* ((lng (length lst))                                                      
         (parts (triangular lng)))                                               
    (let loop ((rn (/ (random 1000000) 1000000.0))                               
               (lp lng)                                                          
               (in lst))                                                         
      (let ((p (/ lp (* 1.0 parts))))                                            
        (if (< rn p)                                                             
            (car in)                                                             
            (loop (- rn p) (- lp 1) (cdr in)))))))

(define (best population)
   (if (null? population) '() (caar population)))

(define (iterate population iteration)
    (if (stop? population iteration)
        (best population)
        (iterate (trunc (population-evolve population) 600)
                 (+ iteration 1))))

(define (population-evolve population)
  (population-mutate (population-cross population)))

(define (population-mutate population)
  (if (null? population)
      '()
      (let loop ((in (cdr population))
                 (out (population-increase (make-population)
                                           (best population))))
        (if (null? in)
            out
            (loop (cdr in)
                  (population-increase out (evolve (best in) population)))))))

(define (evolve specimen population)
   (mutate specimen 35))

(define (population-cross population)
  (define elite (best population))
  (let loop ((in (cdr population))
             (out (population-increase (make-population) elite)))
    (if (null? in)
        out
        (loop (cdr in)
            ;  (let ((childs (cross (car (wchoose population)) (best in))))
              (let ((childs (cross elite (best in))))
                (population-increase (population-increase out (car childs)) (cdr childs)))))))

(define (cross a b)
    (if (and (pair? a) (pair? b))
        (cons `(,(car a) ,(cadr a) ,(caddr b))
              `(,(car b) ,(cadr b) ,(caddr a)))
        (cons a b)))

(define (choose options)
   (list-ref options (random (length options))))

(define (div a b)
   (if (= b 0)
       1
       (/ a b)))

(define (mutate specimen rate)
    (define (random-number)
       (choose '(0 1 2 3 5 7 11 13 17 10000 100000 1000000 10000000 100000000)))
    (define (insert-var)
      (choose '(x y)))
    (define (random-atom ignore)
       ((choose `(,random-number ,insert-var))))
    (define (random-operator)
      (choose `(- + * div)))
    (define (random-application s)
       `(,(random-operator) ,s ,s))
    (define (inc-atom a)
      (if (number? a)
          (+ a 1)
          `(+ 1 ,a)))
    (define (dec-atom a)
      (if (number? a)
          (- a 1)
          `(- 1 ,a)))
    (define (mutate-atom s)
      ((choose `(,random-atom ,random-application ,inc-atom ,dec-atom)) s))
    (define (swap-args a)
      `(,(car a) ,(caddr a) ,(cadr a)))
    (define (change-operator a)
      `(,(random-operator) ,(caddr a) ,(cadr a)))
    (define (mutate-car a)
      `(,(car a) ,(do-mutate (cadr a)) ,(caddr a)))
    (define (mutate-cdr a)
      `(,(car a) ,(cadr a) ,(do-mutate (caddr a))))
    (define (mutate-app a)
      ((choose (list random-atom random-application swap-args
                     change-operator mutate-car mutate-car mutate-car
                     mutate-cdr mutate-cdr mutate-cdr mutate-cdr)) a))
    (define (do-mutate node)
      (if (atom? node)
          (mutate-atom node)
          (mutate-app node)))
    (let loop ((i rate)
               (node specimen))
      (if (> i 0)
          (loop (- i 1) (do-mutate node))
          node)))

(define (initial-population size)
  (let loop ((population (make-population))
             (i 0))
    (if (equal? i size)
        population
        (loop (population-increase population '0) (+ i 1)))))

(define (specimen-length specimen)
   (if (pair? specimen)
       (+ 1 (specimen-length (car specimen)) (specimen-length (cdr specimen)))
       1))

(define (run-specimen specimen vars a b)
  (eval `((lambda ,vars ,specimen) ,a ,b)))

(define (square x) (* x x))

(define (error specimen)
   (+ (square (rerror specimen)) (specimen-length specimen)))

(define (trunc lst s)
   (if (and (pair? lst) (> s 0))
       (cons (car lst) (trunc (cdr lst) (- s 1)))
       '()))

(define (close-to a b)
  (square (abs (- a b))))

(define (sample x y) (* x (* x (div y 6))))


(define (simplify x)
   (if (pair? x)
       (simplify-app x)
       x))

(define (simplify-add la ra)
  (if (eq? la 0)
      (simplify ra)
      (if (eq? ra 0)
          (simplify la)
          `(+ ,(simplify la) ,(simplify ra)))))

(define (simplify-sub la ra)
  (if (eq? ra 0)
      (simplify la)
      `(- ,(simplify la) ,(simplify ra))))

(define (simplify-mul la ra)
  (if (eq? ra 0)
      0
      (if (eq? la 0)
          0
          (if (eq? la 1)
              (simplify ra)
              (if (eq? ra 1)
                  (simplify ra)
                  `(* ,(simplify la) ,(simplify ra)))))))

(define (simplify-div la ra)
  (if (eq? ra 0)
      1
      (if (eq? ra 1)
          (simplify la)
          (if (equal? ra la)
              1
              `(div ,(simplify la) ,(simplify ra))))))
              

(define (simplify-app a)
   (if (and (number? (cadr a)) (number? (caddr a)))
       (eval a)
       (let ((op (car a))
             (la (cadr a))
             (ra (caddr a)))
         (cond ((eq? op '+) (simplify-add la ra))
               ((eq? op '-) (simplify-sub la ra))
               ((eq? op '*) (simplify-mul la ra))
               ((eq? op 'div) (simplify-div la ra))
               (#t `(,(car a) ,(simplify (cadr a)) ,(simplify (caddr a))))))))

(define (rerror specimen)
(define (try-at n y)
     (close-to (run-specimen specimen '(x y) n y) (sample n y)))
   (+ 
      (try-at 43 96)
      (try-at 3 3)
      (try-at 10 -28)
      (try-at 1 2)
      (try-at -9 7)
      (try-at -1 -3)
      (try-at 1000 1510)
      (try-at -8 1919)
   ))

(define (stop? pop i)
    (display "generation number ")
    (display i)
    (newline)
    (display "best current specimen: ")
    (display (caar pop))
    (newline)
    (display "with error: ")
    (display (rerror (caar pop)))
    (newline)
    (newline)
    (if (> i 2000)
        (begin (display "stopping due to max generations")
               (newline)
               #t)
        (if (= 0 (rerror (caar pop)))
            (begin (display "stopping due to perfect specimen found")
                   (newline)
                   #t)
             #f)))
 
(iterate (initial-population 4) 0)
